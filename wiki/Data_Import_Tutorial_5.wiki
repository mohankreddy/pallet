#summary Data Import Tutorial 5[Final Document for Data Import Section]

= Introduction =
This tutorial is in the continuation of Data_Import_Tutorial 1,2,3,4. This is the last 
tutorial which completes the Data Import Section of the Mallet.
 * Feature Count Pipe
 * Feature Value String 2 Feature Vector
 * Token Sequence 2 Feature Vector Sequence
 * Feature Vector Sequence 2 Feature Vectors
 * Filter Empty Feature Vector
 * Instance List Trim Features By Count
 * Noop
 * Pipe
 * PrintInput
 * Print Token Sequence Features
 * Save Data In Source
 * Selective SGML 2 Token Sequence
 * Simple Tagger Sentence 2 String Tokenization
 * Token 2 Feature Vector
 * Token Sequence 2 Token Instances
 * Token Sequence Parse Feature String
 * Augmentable Feature Vector Add Conjunction



==Feature Count Pipe ==
This pipe is used to prune the features which have low count.It is used in order to save the memory which could have been occupied by low count features.This class supports a simpler method that makes two passes over the data : one to collect statistics and create an augumented "stop list",and secondly to actually create instances.

===Implementation===

 * 1) FeatureCountPipe(): This is a simple constructor with no parameters which creates the instance of FeatureCountPipe.

 * 2)FeatureCountPipe(Alphabet datalphabet,Alphabet targetAlphabet): User can supply data alphabet and target alphabet explicity .

===Methods===

 * 1)void addPrunedWordsToStoplist(SimpleTokenizer tokenizer, int minimumCount): Add all pruned words to the internal stoplist of a SimpleTokenizer.

 * 2)Alphabet getPrunedAlphabet(int minimumcount): Return a new Alphabet that contains only features at or above the specified limit

 * 3)void writeCommonWords(java.io.File commonfile,int totalwords): List the most common words ,for addition to a stop file.

 * 4)void writePrunedWords(java.io.File prunedfile,int minimumcount): Write a list of features that do not occur at or above the specified cutoff to the pruned file,one per file. 

 * 5)Instance pipe(Instance instance): Method used to process the data.

===Sample Code===

{{{
import cc.mallet.pipe.*;
import cc.mallet.types.*;
import java.io.*;

public class ImportExample200 {
	static Pipe pipe=null;
	
	public static void main(String args[])
	{
         SimpleTokenizer st=new SimpleTokenizer(1);
		
   String trainingdata="on the plains of  africa the lions123  roar the";
      Instance i=new Instance(trainingdata,"africa","Instance-1",null);
	Input2CharSequence i2cs=new Input2CharSequence();
	Instance i1=i2cs.pipe(i);
				
  SGML2TokenSequence cs2ts=new SGML2TokenSequence();
		 Instance i2=cs2ts.pipe(i1);
			 
  TokenSequence2FeatureSequence ts2fs=new TokenSequence2FeatureSequence();
		 Instance i3=ts2fs.pipe(i2);
				 
FeatureCountPipe fcp=new FeatureCountPipe(i3.getDataAlphabet(),i3.getTargetAlphabet());->1
		Instance i6=fcp.pipe(i3);--->2
		File f=new File("f200.txt");--->3
		try
		{
		fcp.writePrunedWords(f, 2);---->4
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		}
                }
}}}

 * 1) An instance of Feature Count Pipe is created with Data Alphabet and Target Alphabet of the previous pipe(TokenSequence2FeatureSequence in this case).
 * 2)An instance (i6) is generated which contains the data processed by FeatureCountPipe.
 * 3)A file is created which contains the pruned words.
 * 4)writePrunedWords is called with value 2. It means the words which doesn't occur more than 2 times will be pruned.

===Output===
{{{
1)The file f200.txt will contains 
on
of
africa
lions
roar
}}}
These all words doesn't occur more than two times in the raw data so will be pruned from feature set.

==Feature Value String 2 Feature Vector==
It is simple pipe which converts the Feature Value String 2 Feature Vector.

===Implementation===

 * 1)FeatureValueString2FeatureVector(): It is no argument constructor which simply creates an instance of FeatureValueString2FeatureVector.

 * 2)FeatureValueString2FeatureVector(Alphabet alphabet): If user wants to give Alphabet  externally then should use this constructor.

===Sample code===
{{{

import cc.mallet.pipe.*;
import cc.mallet.types.*;

public class ImportExample901 {
	static Pipe pipe=null;
	
	
	public static void main(String args[])
	{
		
		
  String trainingdata="width=60 height=10 length=20 width=80";-------->1
  Instance i=new Instance(trainingdata,"africa","Instance-1",null);
  FeatureValueString2FeatureVector i2cs=new FeatureValueString2FeatureVector();----->2
	Instance i1=i2cs.pipe(i);
	PrintInputAndTarget piat=new PrintInputAndTarget();
	Instance i5=piat.pipe(i1);
		
	}

}
}}}
 * 1)The feature value string is used as the training set.
 * 2) An instance of FeatureValueString2FeatureVector is created.

===Output===
The Feature Value String is converted int Feature Vector.
{{{
name: Instance-1
input: width(0)=140.0(Two occurences of the width is added)

height(1)=10.0

length(2)=20.0

target: africa

}}}
==Token Sequence 2 Feature Vector Sequence==
It is pipe which take input as Token Sequence of Instances and convert it into Feature 
Vector Sequence.

===Implementation===

 * 1)TokenSequence2FeatureVectorSequence():

 * 2)TokenSequence2FeatureVectorSequence(Alphabet dataDict):

 * 3)TokenSequence2FeatureVectorSequence(Alphabet dataDict, boolean binary, boolean augmentable): 

 * 4)TokenSequence2FeatureVectorSequence(boolean binary, boolean augmentable): 

dataDict: If user explicity wants to provide data Alphabet.
augmentable: It it is true than augmentable feature vector is created.

===Sample Code===

{{{

import cc.mallet.pipe.*;
import cc.mallet.types.*;

public class ImportExample54{
	static Pipe pipe=null;
	
	
	public static void main(String args[])
	{
		
 String trainingdata="<abc> on the plains of </abc> africa the <a> lions123 has roared</a> life ";
	Instance i=new Instance(trainingdata,"africa","Instance-1",null);
	Input2CharSequence i2cs=new Input2CharSequence();
	Instance i1=i2cs.pipe(i);
	SGML2TokenSequence cs2ts=new SGML2TokenSequence();
	Instance i2=cs2ts.pipe(i1);
	Target2LabelSequence t2fs=new Target2LabelSequence();
	Instance i8=t2fs.pipe(i2);
TokenSequence2FeatureVectorSequence ts2fvs=new TokenSequence2FeatureVectorSequence();--->1
	Instance i6=ts2fvs.pipe(i8);
	PrintInputAndTarget piat=new PrintInputAndTarget();
	Instance i5=piat.pipe(i6);	
	
	}
}

}}} 

 * 1)An instance of TokenSequence2FeatureVectorSequence is created.

===Output===
{{{
name: Instance-1
input: cc.mallet.types.FeatureVectorSequence@1ffb8dc------>Token sequence is converted 
0:                                                         into feature Vector Sequence
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 

target: 0: abc (0)
1: abc (0)
2: abc (0)
3: abc (0)
4: O (1)
5: O (1)
6: a (2)
7: a (2)
8: a (2)
9: O (1)
}}}

==Feature Vector Sequence 2 Feature Vectors==
It is the pipe which converts the Feature Vector Sequence to Feature Vectors. The previous pipe (TokenSequence2FeatureVectorSequence) converts the token sequence to feature vector sequence and this pipe than subsequently converts the given Feature Vector Sequence to Feature Vectors.So given an instance with a Feature Vector Sequence in the data field ,it break up the sequence into the individual feature vectors producing one feature vector per instance.

===Implementation===

 * 1)FeatureVectorSequence2FeatureVectors(): It simply creates an instance of FeatureVectorSequence2FeatureVectors pipe.

===Method===
 * 1)
{{{
Iterator<Instance> newIteratorFrom(java.util.Iterator<Instance> inputIterator): 
}}}
Take in input as an Instance iterator and return the Instance Iterator whose instances are already processed through FeatureVectorSequence2FeatureVectors pipe.



===Sample Code===

The instances which is passed through TokenSequence2FeatureVectorSequence is added to the InstanceList. Then an iterator which is used to iterate the previous InstanceList is passed to the newIteratorFrom method of the FeatureVectorSequence2FeatureVectors pipe. These methods returns the iterator which contains the individual feature vectors producing one feature vector per instance.

===Output===
Output contains individual feature vectors per instance.


==Filter Empty Feature Vector==
This pipe provides functionality of iterating through Feature Vectors individually.

===Implementation===

 * 1)FilterEmptyFeatureVectors() : It simply creates an instance of FilterEmptyFeatureVectors pipe.

===Method===

 * 1)
{{{
public Iterator<Instance> newIteratorFrom (Iterator<Instance> source) 
}}}

Given an Instance Iterator , return a new Instance Iterator whose instances have also been processed by this pipe.


===Sample Code===
{{{
import java.io.IOException;

import java.io.*;
import java.util.*;
import java.util.regex.*;

import cc.mallet.classify.Classification;
import cc.mallet.classify.Classifier;
import cc.mallet.classify.ClassifierTrainer;
import cc.mallet.classify.NaiveBayesTrainer;
import cc.mallet.pipe.*;
import cc.mallet.pipe.iterator.*;
import cc.mallet.types.*;

public class ImportExample202 {
	static Pipe pipe=null;
	static InstanceList instancelist = null;
	static Classifier cls=null;
	static FeatureCountPipe ob11=null;
	static TokenSequence2FeatureSequence ob10=null;
	public Pipe buidPipe()
	{
		ArrayList pipeList = new ArrayList();
		
   pipeList.add(new Input2CharSequence("UTF-8"));
       
      Pattern tokenPattern =
         Pattern.compile("[\\p{L}\\p{N}_]+");
        pipeList.add(new CharSequence2TokenSequence(tokenPattern));
   
     pipeList.add(new TokenSequence2FeatureSequence());
     
   
      pipeList.add(new Target2Label());
   
     pipeList.add(new FeatureSequence2FeatureVector());
       
   pipeList.add(new PrintInputAndTarget());
        
        return(new SerialPipes(pipeList));
		
	}
	
	
	public static void main(String args[])
	{
		ClassifierTrainer trainer = null; 
		String [][][] trainingdata = new String [][][] {
				{{ "on the plains of africa the lions roar",
				  "in swahili ngoma means to dance",
				  "nelson mandela became president of south africa",
				  "the saraha dessert saraha expanding"}, {"africa"}},				  
				{{ "panda bears eat bamboo",
				  "china's one child policy has resulted in a surplus of boys",
				  "tigers live in the jungle"}, {"asia"}},
				{{ "home of kangaroos",
				  "Autralian's for beer - Foster",
				  "Steve Irvin is a herpetologist"}, {"australia"}}				 
		};
		ImportExample202 ob1=new ImportExample202();
		pipe=ob1.buidPipe();
		InstanceList instances = new InstanceList(pipe);--------->1
		for (int i = 0; i < 3; i++) {
			try {
			 instances.addThruPipe (new ArrayIterator (trainingdata[i][0],trainingdata[i][1][0]));
			} catch (Exception e) { System.out.println(e);}
		}
	   Iterator<Instance> i3 = instances.iterator();---------->2
	
	   FilterEmptyFeatureVectors fefv=new FilterEmptyFeatureVectors ();------>3
		Iterator<Instance>i4=fefv.newIteratorFrom(i3);------>4
		while(i4.hasNext())
		{
		   Instance i8=i4.next();
		  		   PrintInputAndTarget piat=new PrintInputAndTarget();
			Instance i5=piat.pipe(i8);--------->5
		
		}
		
		
		
		
	}

}
}}}

 * 1) An InstanceList is created which contains feature vectors.
 * 2) An Iterater is created corresponding to the above InstanceList.
 * 3) An object of FilterEmptyFeatureVectors is created.
 * 4) The newIteratorFrom method of the FilterEmptyFeatureVectors is called.It returns a iterator which can be used to process the feature vectors individually.
 * 5) The feature vector is processed individually by PrintInputAndTarget pipe.

===Output===
{{{
name: array:0
input: on(0)=1.0
the(1)=2.0
plains(2)=1.0
of(3)=1.0
africa(4)=1.0
lions(5)=1.0
roar(6)=1.0

target: africa
name: array:1
input: in(7)=1.0
swahili(8)=1.0
ngoma(9)=1.0
means(10)=1.0
to(11)=1.0
dance(12)=1.0

target: africa
name: array:2
input: of(3)=1.0
africa(4)=1.0
nelson(13)=1.0
mandela(14)=1.0
became(15)=1.0
president(16)=1.0
south(17)=1.0

target: africa
name: array:3
input: the(1)=1.0
saraha(18)=2.0
dessert(19)=1.0
expanding(20)=1.0

target: africa
name: array:0
input: panda(21)=1.0
bears(22)=1.0
eat(23)=1.0
bamboo(24)=1.0

target: asia
name: array:1
input: of(3)=1.0
in(7)=1.0
china(25)=1.0
s(26)=1.0
one(27)=1.0
child(28)=1.0
policy(29)=1.0
has(30)=1.0
resulted(31)=1.0
a(32)=1.0
surplus(33)=1.0
boys(34)=1.0

target: asia
name: array:2
input: the(1)=1.0
in(7)=1.0
tigers(35)=1.0
live(36)=1.0
jungle(37)=1.0

target: asia
name: array:0
input: of(3)=1.0
home(38)=1.0
kangaroos(39)=1.0

target: australia
name: array:1
input: s(26)=1.0
Autralian(40)=1.0
for(41)=1.0
beer(42)=1.0
Foster(43)=1.0

target: australia
name: array:2
input: a(32)=1.0
Steve(44)=1.0
Irvin(45)=1.0
is(46)=1.0
herpetologist(47)=1.0

target: australia
name: array:0
input: on(0)=1.0
the(1)=2.0
plains(2)=1.0
of(3)=1.0
africa(4)=1.0
lions(5)=1.0
roar(6)=1.0

target: africa
name: array:1
input: in(7)=1.0
swahili(8)=1.0
ngoma(9)=1.0
means(10)=1.0
to(11)=1.0
dance(12)=1.0

target: africa
name: array:2
input: of(3)=1.0
africa(4)=1.0
nelson(13)=1.0
mandela(14)=1.0
became(15)=1.0
president(16)=1.0
south(17)=1.0

target: africa
name: array:3
input: the(1)=1.0
saraha(18)=2.0
dessert(19)=1.0
expanding(20)=1.0

target: africa
name: array:0
input: panda(21)=1.0
bears(22)=1.0
eat(23)=1.0
bamboo(24)=1.0

target: asia
name: array:1
input: of(3)=1.0
in(7)=1.0
china(25)=1.0
s(26)=1.0
one(27)=1.0
child(28)=1.0
policy(29)=1.0
has(30)=1.0
resulted(31)=1.0
a(32)=1.0
surplus(33)=1.0
boys(34)=1.0

target: asia
name: array:2
input: the(1)=1.0
in(7)=1.0
tigers(35)=1.0
live(36)=1.0
jungle(37)=1.0

target: asia
name: array:0
input: of(3)=1.0
home(38)=1.0
kangaroos(39)=1.0

target: australia
name: array:1
input: s(26)=1.0
Autralian(40)=1.0
for(41)=1.0
beer(42)=1.0
Foster(43)=1.0

target: australia
name: array:2     -----Feature Vectors are processed individualy.
input: a(32)=1.0
Steve(44)=1.0
Irvin(45)=1.0
is(46)=1.0
herpetologist(47)=1.0

target: australia
}}}

==Instance List Trim Features By Count==
This pipe is unimplemented in the Mallet as of now.

==Noop==
It is the pipe which does nothing to the instance fields but which has the side effects on the dictionary.Noop creates the Dictionary from dataAlphabet and targetAlphabet which can be used by the DictinariedPipe's.You might want to use this pipe before Parallel pipes where the previous pipe do not need dictionaries ,but later steps in each parallel paths do,and they all must share the same directory.  

===Implementation===

 * 1)Noop(): It is a simple constructor which does nothing.
 * 2)Noop(Alphabet dataDict,Alphabet targetDict): It is the constructor which creates the dictionary from the given data Alphabet and target Alphabet.It forces the creation of Alphabet ,so that pipes which based on Alphabet can use it.

===Sample Code===
{{{

import cc.mallet.pipe.*;
import cc.mallet.types.*;
import java.util.regex.*;

public class ImportExample4044 {
	static Pipe pipe=null;
        public static void main(String args[])
	{
		String trainingdata="on the plains of africa the lions roar";
		Instance i=new Instance(trainingdata,"africa","Instance-1",null);
		Input2CharSequence i2cs=new Input2CharSequence();
		Instance i1=i2cs.pipe(i);
				
		
       Pattern tokenPattern =
	           Pattern.compile("[\\p{L}\\p{N}_]+");
CharSequence2TokenSequence cs2ts =new    CharSequence2TokenSequence(tokenPattern);
			 Instance i2=cs2ts.pipe(i1);
			 
 TokenSequence2FeatureSequence ts2fs=new TokenSequence2FeatureSequence();
		 Instance i3=ts2fs.pipe(i2);
				 
  Noop n1=new Noop(i3.getDataAlphabet(),i3.getTargetAlphabet());------>1 
		 Instance in=n1.pipe(i3);
		 
	 Target2Label t2l=new Target2Label();
	Instance i4=t2l.pipe(in);
		 
  FeatureSequence2FeatureVector fs2afv=new FeatureSequence2FeatureVector();
		Instance i6=fs2afv.pipe(i4);
		
		
		PrintInputAndTarget piat=new PrintInputAndTarget();
		Instance i5=piat.pipe(i6);
		
	}

}
}}}

 * 1)Noop forces the creation of dictionary or dataAlphabet and TargetAlphabet which can be further used by Target2Label and FeatureSequence2FeatureVector pipes.

===Sample Output===
The dataAlphabet and targetAlphabet is created by the use Noop.


